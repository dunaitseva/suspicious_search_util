# Анализ решения

Для беседы на интервью проанализировал свой код, сделал кое-какие выводы и подготовил список основных
поинтов, чтобы рассказывать о том, каким образом решал задачу, какие архитектурные приемы использовал,
какие ошибки допустил.

### Задание

Требуется реализовать утилиту на языке C++, работающую из командной строки, выполняющую сканирование файлов
в директории, с целью нахождение в ней “подозрительных” (suspicious) файлов.

В рамках задачи определено 3 типа “подозрительного” содержимого в файле:

JS suspicious: файл с расширением .js, содержащий строку: <script>evil_script()</script>
CMD suspicious: файл с расширением CMD/BAT, содержащий строку: rd /s /q "c:\windows"
EXE suspicious: файл с расширением EXE/DLL, содержащий строки: CreateRemoteThread, CreateProcess

## Ход решения

#### Поисковик файлов

Необходимость поисковика. Интерфейсный класс BasicFileFinder. Решение использовать std::filesystem.
Поисковик регулярных файлов (надо сказать, что непосредственно занимается формированием списка файла).

#### Хранилище подозрительных вхождений для файлов

Хотя в задании сказано, что в данном контексте мы имеем строго ограниченное количество вхождений,
я не хотел их хардкодить. Кроме того, мне показалось, что в реальной жизни программа будет узнавать
о подобных вхождениях из некоторого рода хранилища. Поэтому я сделал простейший интерфейс такого хранилища
и небольшую имплементацию хранилища на основе хэш-таблицы. Добавил интерфейс доступа в виде `StorageAccessor`.
Сделал это руководствуясь DIP. То есть при необходимости нагрузить операцию доступа к хранилищу каким-то
обвесом (логирование, аутентификация и тд), необходимо будет просто добавить этот обвес внутри интерфейса
доступа.

#### Сканер файлов и анализатор файлов

Здесь я воспользовался паттерном "фабричный метод". Создателем тут является анализатор. Основная цель анализатора
обрабатывать файл со специфичным расширением и выносить решение о том, является ли он подозрительным. Одной из подзадач
анализатора является анализ файла на основе его содержимого, поэтому каждый анализатор создает продукт в виде сканера
файлов (Каждый анализатор создает сканер по своему в методе `CreateScanner`).

**Отдельно по сканеру.**

- Алгоритм было решено сделать многопоточным.
- Вычислил максимальное количество потоков, которые машина может мне предоставить, так, мне кажется, 
  я смогу достичь наибольшей степени утилизации ресурсов.
- Побил файл на чанки в количестве равном количеству потоков.
- Создал пул потоков и распределил между ними чанки для анализа.
- Каждый поток анализирует свою часть файла, и если решает, что файл подозрительный,
  останавливает все потоки (благодаря флагу decision).
- Джоиним все потоки

#### Формирование отчета

Сделал небольшой метод, который формирует объект отчета по анализу директории в заданной форме.
Класс отчета можно выводить в поток.

## Ошибки

- Некоторые классы спроектированы неверно, то есть их объекты нельзя переиспользовать
  в одном месте без пересоздания объекта. Это вызвано тем, что необходимые для работы одного метода
  данные я передаю в конструкторе, когда их нужно передавать в сам метод. Так, например, я передаю классу
  `RegularBasicFileFinder` путь к директории поиска в конструкторе, хотя нужно передавать путь в метод
  `CreateFilesList`, тогда я смог бы использовать этот объект несколько раз для разных входных данных.

- Несколько заигрался с созданиями классов исключений, сейчас мне кажется это не совсем правильный подход.
  Для примера, можно было бы не создавать классы `DirectoryNotFound` и `NotDirectory`, так как соответствующие
  исключения `std::filesystem` способна бросать самостоятельно.

- Зря сделал `BasicFilesFinder` шаблонным. Без шаблона интерфейс был бы более общим (если мы например хотим
  наследоваться и работать не на основе `std::filesystem`).
